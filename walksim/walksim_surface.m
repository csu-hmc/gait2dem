function walksim_surface(filename)

% This is a simple program to optimize the gait2dem model controller gains.

%=====================================================================================

global control perturb kp kd Result
tic;

duration = 100.0;		% allow for a maximum 100 second walk
pfmag = 1.0;		    % how fast the perturbation grows (N/s)
lb = [1 1];             % lower bound of kd/kp for optimization
ub = [2000 100];        % upper bound of kd/dp for optimization
gridsize = [30 30];		% 

% load the optimization resultsim (using 'result005')

load(filename);

xinit = Result.x(:,1);                                                                                                                      % = initial state
%
control.durcycle=2*Result.dur;                                                                                                  % 2 half gait cycles + 1 data point (801 data points)
control.x0 = [Result.x';Result.x(Result.problem.vmx,:)'];
control.u0 = [Result.u';Result.u(Result.problem.vmu,:)'];
control.u0 = control.u0(:,4:end);                                                                                                % throw away the first 3 columns
control.u0 = [control.u0 ; control.u0(1,:)];                                                                               % add data for the last missing data point
control.x0 = [control.x0 ; control.x0(1,:)];                                                                                % add data for the last missing data point
control.tsamples = (0:2*Result.problem.N)*control.durcycle/(2*Result.problem.N);           

% map the performance as a function of k
k1 = zeros(gridsize);
k2 = zeros(gridsize);
f = zeros(gridsize);
for ik1 = 1:gridsize(1)
    for ik2 = 1:gridsize(2)
        k1(ik1,ik2) = lb(1) + (ik1-1)*(ub(1)-lb(1))/(gridsize(1)-1);
        k2(ik1,ik2) = lb(2) + (ik2-1)*(ub(2)-lb(2))/(gridsize(2)-1);
		perturb.t = 0:0.1:duration;
		perturb.Force = pfmag*perturb.t.*rand(size(perturb.t));
        f(ik1,ik2) = walk([k1(ik1,ik2) k2(ik1,ik2)]);
    end
end
surfc(k1,k2,f);
xlabel('Kp (N*m/radian)')
ylabel('Kd (N*m*s/radian)');
zlabel('f (s)');
% keyboard

% % smooothing the response surface
% kernel = [.05 .1 .05; .1 .4 .1; .05 .1 .05];
% f = conv2(f,kernel,'same');
% surfc(k1,k2,f);
% xlabel('Kp (N*m/radian)')
% ylabel('Kd (N*m*s/radian)');
% zlabel('f (s)');

%=====================================================================
% Run the simulation and compute minus duration
    function [walktime] = walk(k)                       % gain matrix k to be minimized
        kp = k(1);                                      % first entry in k gain matrix
        kd = k(2);                                      % second entry in k gain matrix
        K1=[0 0 0 -kp 0 0 0 0 0 0 0 0 -kd 0 0 0 0 0];
        K2=[0 0 0 0 -kp 0 0 0 0 0 0 0 0 -kd 0 0 0 0];
        K3=[0 0 0 0 0 -kp 0 0 0 0 0 0 0 0 -kd 0 0 0];
        K4=[0 0 0 0 0 0 -kp 0 0 0 0 0 0 0 0 -kd 0 0];
        K5=[0 0 0 0 0 0 0 -kp 0 0 0 0 0 0 0 0 -kd 0];
        K6=[0 0 0 0 0 0 0 0 -kp 0 0 0 0 0 0 0 0 -kd];
        control.K=[K1;K2;K3;K4;K5;K6];                  % gain matrix
                  
		options = odeset('Events',@events);
		[~,~,walktime] = ode15s(@odefun, [0 duration], xinit, options);
        fprintf('Gains: %8.3f %8.3f -- walk duration %10.5f\n', k, walktime);
    end

end
%=====================================================================================
function [xdot] = odefun(t,x)                          % function to calculate perturb force,
% joint torques, and state derivatives
	global perturb 
	Force = interp1(perturb.t,perturb.Force,t);        % Perturbation force acting on x1 (hip)
	tau = [Force; 0; 0; controller(t,x)];		       % six joint torques are generated by a controller
	xdot = gait2dem(x,tau);                            % state derivates
end
%=====================================================================================
function [u] = controller(t,x)                         % controller input 'u' as a function of time and state
	global control
	tper = mod(t,control.durcycle);                    % modulo of t/control.durcycle
	x0t = interp1(control.tsamples,control.x0,tper)';  % initial position
	u0t = interp1(control.tsamples,control.u0,tper)';  % initial input to the controller
	u = u0t+control.K*(x-x0t);                         % control law
end
%=====================================================================================
function [value,isterminal,direction] = events(~,x)
% this function defines an event that terminates the simulation
	height = 0.75;         		% uses hip height to indicate the model has fallen
	value = (x(2) - height);	% simulation will stop when this becomes zero
	isterminal = 1;
	direction = -1;
end